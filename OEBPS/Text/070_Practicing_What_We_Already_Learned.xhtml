<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title>Practicing what we already learned</title>
  <link href="../Styles/Global.css" rel="stylesheet" type="text/css"/>
</head>

<body>
  <h1>Practicing what we already learned</h1>

  <blockquote>
    <p>And now, a taste of things to come!</p>

    <p>- Shang Tsung, Mortal Kombat The Movie</p>
  </blockquote>

  <p>The above quote took place just before a fighting scene in which a nameless warrior jumped at Sub-Zero only to be frozen and broken into multiple pieces upon hitting the wall. The scene was not spectacular in terms of fighting technique or length. Also, the nameless guy did not even try hard - the only thing he did was to jump only to be hit by a freezing ball, which, by the way, he actually saw coming. It looked a lot like the fight was set up only to showcase Sub-Zero’s freezing ability. Guess what? In this chapter, we are gonna do roughly the same thing - set up a fake, easy scenario just to showcase some of the basic TDD elements!</p>

  <p>The previous chapter was filled with a lot of theory and philosophy, don’t you think? I really hope you did not fall asleep while reading it. To tell you the truth, we need to grasp much more theory until we are really able to write real-world applications using TDD. To compensate for this somehow, I propose we make a side trip from the trail and try what we already learned on a quick and easy example. As we go through the example, you might wonder how on earth could you possibly write real applications the way we will write our simple program. Do not worry, I will not show you all the tricks yet, so treat it as a “taste of things to come”. In other words, the example will be as close to real world problems as the fight between Sub-Zero and nameless ninja was to real martial arts fight, but will show you some of the elements of TDD process.</p>

  <h2 id="sigil_toc_id_8">Let me tell you a story</h2>

  <p>Meet Johnny and Benjamin, two developers from Buthig Company. Johnny is quite fluent in programming and Test-Driven Development, while Benjamin is an intern under Johnny’s mentorship and is eager to learn TDD. They are on their way to their customer, Jane, who requested their presence as she wants them to do write a small program for her. Together with them, we will see how they interact with the customer and how Benjamin tries to understand the basics of TDD. Just as you, Benjamin is a novice so his questions may reflect yours. However, if you find anything explained in not enough details, do not worry - in the next chapters, we will be expanding on this material.</p>

  <h2 id="sigil_toc_id_9">Act 1: The Car</h2>

  <p><strong>Johnny:</strong> How do you feel on your first assignment?</p>

  <p><strong>Benjamin:</strong> I am pretty excited! I hope I can learn some of the TDD stuff you promised to teach me.</p>

  <p><strong>Johnny:</strong> Not only TDD, but we are also gonna use some of the practices associated with a process called Acceptance Test Driven Development, albeit in a simplified form.</p>

  <p><strong>Benjamin:</strong> Acceptance Test-Driven Development? What is that?</p>

  <p><strong>Johnny:</strong> While TDD is usually referred to as a development technique, ATDD is something more of a collaboration method. Both ATDD and TDD have a bit of analysis in them and work very well together as both use the same underlying principles, just on different levels. We will need only a small subset of what ATDD has to offer, so do not get over-excited.</p>

  <p><strong>Benjamin:</strong> Sure.</p>

  <h2 id="sigil_toc_id_10">Act 2: The Customer</h2>

  <p><strong>Johnny:</strong> Hi, Jane, how are you?</p>

  <p><strong>Jane:</strong> Thanks, I am fine, how about you?</p>

  <p><strong>Johnny:</strong> Same here, thanks. So, can you tell us a bit about the software you need us to write?</p>

  <p><strong>Jane:</strong> Sure. Recently, I bought a new smartphone as a replacement for my old one. The thing is, I am really used to the calculator application that was running on the previous phone and I cannot find it for my current device.</p>

  <p><strong>Benjamin:</strong> Can't you just use another calculator app? There are plenty of them available to download from the web.</p>

  <p><strong>Jane:</strong> That is right. I checked them all and none has exactly the same behavior as the one I was using for my tax calculations. You know, the program was like right hand to me and it had some really nice shortcuts that made my life easier.</p>

  <p><strong>Johnny:</strong> So you want us to reproduce the application to run on your new device?</p>

  <p><strong>Jane:</strong> Yes.</p>

  <p><strong>Johnny:</strong> Are you aware that apart from the fancy features that you were using we will have to allocate some effort to implement the basics that all the calculators have?</p>

  <p><strong>Jane:</strong> Sure, I am OK with that. I am so used to my calculator application so much that if I use something else for more than few months, I will have to pay psychotherapist instead of you guys. Apart from that, writing a calculator app seems like a simple task in my mind, so the cost isn’t going to be overwhelming, right?</p>

  <p><strong>Johnny:</strong> I think I get it. Let us get it going then. We will be implementing the functionality incrementally, starting with the most essential ones. Which feature of the calculator would you consider the most essential?</p>

  <p><strong>Jane:</strong> That would be addition of numbers, I guess.</p>

  <p><strong>Johnny:</strong> Ok, that will be our target for the first iteration. After the iteration, we will deliver this part of functionality for you to try out and give us some feedback. However, before we can even implement addition, we will have to implement displaying digits on the screen as you enter them. Is that correct?</p>

  <p><strong>Jane:</strong> yes, I want the display stuff to work as well - it is the most basic feature, so…</p>

  <p><strong>Johnny:</strong> Ok then, this is a simple functionality, so let me suggest some user stories as I understand what you already said and you will correct me where I am wrong. Here we go:</p>

  <ol>
    <li><strong>In order to</strong> know that the calculator is turned on, <strong>As a</strong> tax payer <strong>I want</strong> to see “0” on the screen as soon as I turn it on.</li>

    <li><strong>In order to</strong> see what numbers I am currently operating on, <strong>As a</strong> tax payer, <strong>I want</strong> the calculator to display the values I enter</li>

    <li><strong>In order to</strong> calculate sum of my different incomes, <strong>As a</strong> tax payer <strong>I want</strong> the calculator to enable addition of multiple numbers</li>
  </ol>

  <p>What do you think?</p>

  <p><strong>Jane</strong>: The stories pretty much reflect what I want for the first iteration. I do not think I have any corrections to make.</p>

  <p><strong>Johnny:</strong> Now we will take each story and collect some examples of how it should work.</p>

  <p><strong>Benjamin:</strong> Johnny, don’t you think it is obvious enough to proceed with implementation straight away?</p>

  <p><strong>Johnny:</strong> Trust me, Benjamin, if there is one word I fear most in communication, it is “obvious”. Miscommunication happens most often around things that people consider obvious, simply because other people do not.</p>

  <p><strong>Jane:</strong> Ok, I am in. What do I do?</p>

  <p><strong>Johnny:</strong> Let us go through stories one by one and see if we can find some key examples of how the features work. The first story is…</p>

  <h3 class="sigil_not_in_toc" id="uf3ac031f-9b76-48b2-ac5f-609b8999b7be"><strong>In order to</strong> know that the calculator is turned on, <strong>As a</strong> tax payer <strong>I want</strong> to see “0” on the screen as soon as I turn it on.</h3>

  <p><strong>Jane:</strong> I do not think there is much to talk about. If you display “0”, I will be happy. That is all.</p>

  <p><strong>Johnny:</strong> Let us write down this example:</p>

  <table>
    <tr>
      <th>key sequence</th>

      <th>Displayed output</th>

      <th>Notes</th>
    </tr>

    <tr>
      <td>N/A</td>

      <td>0</td>

      <td>Initial displayed value</td>
    </tr>
  </table>

  <p><strong>Benjamin:</strong> That makes me wonder… what should happen when I press “0” again at this stage?</p>

  <p><strong>Johnny:</strong> Good catch, that is what these examples are for - they make our thinking concrete. As Ken Pugh says: “Often the complete understanding of a concept does not occur until someone tries to use the concept”. We would normally put it on a TODO list, because it is part of a different story, but we are actually done with this one, so let us move straight to the story about displaying entered digits. How about it, Jane?</p>

  <p><strong>Jane:</strong> Agree.</p>

  <h3 class="sigil_not_in_toc" id="u75349e7f-5984-435c-be9e-6a7f4c4c7a35"><strong>In order to</strong> see what numbers I am currently operating on, <strong>As a</strong> tax payer, <strong>I want</strong> the calculator to display the values I enter</h3>

  <p><strong>Johnny:</strong> Let us begin with the case raised by Benjamin. What should happen when I input “0” multiple times after I have only “0” on the display?</p>

  <p><strong>Jane:</strong> Just one “0” should be displayed</p>

  <p><strong>Johnny:</strong> Do you mean this?</p>

  <table>
    <tr>
      <th>key sequence</th>

      <th>Displayed output</th>

      <th>Notes</th>
    </tr>

    <tr>
      <td>0,0,0</td>

      <td>0</td>

      <td>Zero is a special case – it is displayed only once</td>
    </tr>
  </table>

  <p><strong>Jane:</strong> That is right. Other than this, the digits should just show on the screen, like this:</p>

  <table>
    <tr>
      <th>key sequence</th>

      <th>Displayed output</th>

      <th>Notes</th>
    </tr>

    <tr>
      <td>1,2,3</td>

      <td>123</td>

      <td>Entered digits are displayed</td>
    </tr>
  </table>

  <p><strong>Benjamin:</strong> How about this:</p>

  <table>
    <tr>
      <th>key sequence</th>

      <th>Displayed output</th>

      <th>Notes</th>
    </tr>

    <tr>
      <td>1,2,3,4,5,6,7,1,2,3,4,5,6</td>

      <td>1234567123456?</td>

      <td>Entered digits are displayed?</td>
    </tr>
  </table>

  <p><strong>Jane:</strong> Actually, no. My old calculator app has a limit of six digits that I can enter, so it should be:</p>

  <table>
    <tr>
      <th>key sequence</th>

      <th>Displayed output</th>

      <th>Notes</th>
    </tr>

    <tr>
      <td>1,2,3,4,5,6,7,1,2,3,4,5,6</td>

      <td>123456</td>

      <td>Display limited to six digits</td>
    </tr>
  </table>

  <p><strong>Johnny:</strong> another good catch, Benjamin!</p>

  <p><strong>Benjamin:</strong> I think I am beginning to understand why you like working with examples!</p>

  <p><strong>Johnny:</strong> Good. Is there anything else, Jane?</p>

  <p><strong>Jane:</strong> No, that is pretty much it. Let us take another story.</p>

  <h3 class="sigil_not_in_toc" id="u068ecf28-5fd1-40f0-a438-9cedb9486a1c"><strong>In order to</strong> calculate sum of my different incomes, <strong>As a</strong> tax payer <strong>I want</strong> the calculator to enable addition of multiple numbers</h3>

  <p><strong>Johnny:</strong> Is the following all we have to support?</p>

  <table>
    <tr>
      <th>key sequence</th>

      <th>Displayed output</th>

      <th>Notes</th>
    </tr>

    <tr>
      <td>2,+,3,+,4,=</td>

      <td>9</td>

      <td>Simple addition of numbers</td>
    </tr>
  </table>

  <p><strong>Jane:</strong> This scenario is correct, however, there is also a case when I start with “+” without inputting any number before. This should be treated as adding to zero:</p>

  <table>
    <tr>
      <th>key sequence</th>

      <th>Displayed output</th>

      <th>Notes</th>
    </tr>

    <tr>
      <td>+,1,=</td>

      <td>1</td>

      <td>Addition shortcut – treated as 0+1</td>
    </tr>
  </table>

  <p><strong>Benjamin:</strong> How about when the output is a number longer than six digits limit? Is it OK that we truncate it like this?</p>

  <table>
    <tr>
      <th>key sequence</th>

      <th>Displayed output</th>

      <th>Notes</th>
    </tr>

    <tr>
      <td>9,9,9,9,9,9,+,9,9,9,9,9,9,=</td>

      <td>199999</td>

      <td>Our display is limited to six digits only</td>
    </tr>
  </table>

  <p><strong>Jane:</strong> Sure, I do not mind. I do not add such big numbers anyway.</p>

  <p><strong>Johnny:</strong> There is still one question we missed. Let us say that I input a number, then press “+” and then another number without asking for result with “=”. What should I see?</p>

  <p><strong>Jane:</strong> Every time you press “+”, the calculator should consider entering current number finished and overwrite it as soon as you press any other digit:</p>

  <table>
    <tr>
      <th>key sequence</th>

      <th>Displayed output</th>

      <th>Notes</th>
    </tr>

    <tr>
      <td>2,+,3</td>

      <td>3</td>

      <td>Digits entered after + operator are treated as digits of a new number, the previous one is stored</td>
    </tr>
  </table>

  <p><strong>Jane:</strong> Oh, and just asking for result after the calculator is turned on should result in “0”.</p>

  <table>
    <tr>
      <th>key sequence</th>

      <th>Displayed output</th>

      <th>Notes</th>
    </tr>

    <tr>
      <td>=</td>

      <td>0</td>

      <td>Result key in itself does nothing</td>
    </tr>
  </table>

  <p><strong>Johnny:</strong> Let us sum up our discoveries:</p>

  <table>
    <tr>
      <th>key sequence</th>

      <th>Displayed output</th>

      <th>Notes</th>
    </tr>

    <tr>
      <td>N/A</td>

      <td>0</td>

      <td>Initial displayed value</td>
    </tr>

    <tr>
      <td>1,2,3</td>

      <td>123</td>

      <td>Entered digits are displayed</td>
    </tr>

    <tr>
      <td>0,0,0</td>

      <td>0</td>

      <td>Zero is a special case – it is displayed only once</td>
    </tr>

    <tr>
      <td>1,2,3,4,5,6,7</td>

      <td>123456</td>

      <td>Our display is limited to six digits only</td>
    </tr>

    <tr>
      <td>2,+,3</td>

      <td>3</td>

      <td>Digits entered after + operator are treated as digits of a new number, the previous one is stored</td>
    </tr>

    <tr>
      <td>=</td>

      <td>0</td>

      <td>Result key in itself does nothing</td>
    </tr>

    <tr>
      <td>+,1,=</td>

      <td>1</td>

      <td>Addition shortcut – treated as 0+1</td>
    </tr>

    <tr>
      <td>2,+,3,+,4,=</td>

      <td>9</td>

      <td>Simple addition of numbers</td>
    </tr>

    <tr>
      <td>9,9,9,9,9,9,+,9,9,9,9,9,9,=</td>

      <td>199999</td>

      <td>Our display is limited to six digits only</td>
    </tr>
  </table>

  <p><strong>Johnny:</strong> The limiting of digits displayed looks like a whole new feature, so I suggest we add it to the backlog and do it in another sprint. In this sprint, we will not handle such situation at all. How about that, Jane?</p>

  <p><strong>Jane:</strong> Fine with me. Looks like a lot of work. Nice that we discovered it up-front. For me, the limiting capability seemed so obvious that I did not even think it would be worth mentioning.</p>

  <p><strong>Johnny:</strong> See? That is why I do not like the word “obvious”. Jane, we will get back to you if any more questions arise. For now, I think we know enough to implement these three stories for you.</p>

  <p><strong>Jane:</strong> good luck!</p>

  <h2 id="sigil_toc_id_11">Act 3: Test-Driven Development</h2>

  <p><strong>Benjamin:</strong> Wow, that was cool. Was that Acceptance Test-Driven Development?</p>

  <p><strong>Johnny:</strong> In a greatly simplified version, yes. The reason I took you with me was to show you the similarities between working with customer the way we did and working with the code using TDD process. They are both applying the same set of principles, just on different levels.</p>

  <p><strong>Benjamin:</strong> I am dying to see it with my own eyes. Shall we start?</p>

  <p><strong>Johnny:</strong> Sure. If we followed the ATDD process, we would start writing what we call acceptance-level specification. In our case, however, a unit-level specification will be enough. Let us take the first example:</p>

  <h3 class="sigil_not_in_toc" id="u7a1820ab-f461-4f8c-9c40-47de72b1405a">Statement 1: Calculator should display 0 on creation</h3>

  <table>
    <tr>
      <th>key sequence</th>

      <th>Displayed output</th>

      <th>Notes</th>
    </tr>

    <tr>
      <td>N/A</td>

      <td>0</td>

      <td>Initial displayed value</td>
    </tr>
  </table>

  <p><strong>Johnny:</strong> Benjamin, try to write the first Statement.</p>

  <p><strong>Benjamin:</strong> Boy, I do not know how to start.</p>

  <p><strong>Johnny:</strong> start by writing the statement in a plain English. What should the calculator do?</p>

  <p><strong>Benjamin:</strong> It should display “0” when I turn the application on.</p>

  <p><strong>Johnny:</strong> In our case, “turning on” is creating a calculator. Let us write it down as a method name:</p>
  <pre>public class CalculatorSpecification
{

[Fact] public void
ShouldDisplay0WhenCreated()
{

}

}
</pre>

  <p><strong>Benjamin:</strong> Why is the name of the class <code>CalculatorSpecification</code> and the name of the method <code>ShouldDisplay0WhenCreated</code>?</p>

  <p><strong>Johnny:</strong> It is a naming convention. There are many others, but this is the one that I like. The rule is that when you take the name of the class without the <code>Specification</code> part followed by the name of the method, it should form a legit sentence. For instance, if I apply it to what we wrote, it would make a sentence: “Calculator should display 0 when created”.</p>

  <p><strong>Benjamin:</strong> Ah, I see now. So it is a statement of behavior, isn’t it?</p>

  <p><strong>Johnny:</strong> That is right. Now, the second trick I can sell to you is that if you do not know what code to start with, start with the expected result. In our case, we are expecting that the behavior will end up as displaying “0”, right? So let us just write it in form of an assertion.</p>

  <p><strong>Benjamin:</strong> You mean something like this?</p>
  <pre>public class CalculatorSpecification
{

[Fact] public void
ShouldDisplay0WhenCreated()
{
 Assert.Equal("0", displayedResult);
}

}</pre>

  <p><strong>Johnny:</strong> Precisely.</p>

  <p><strong>Benjamin:</strong> But that does not even compile. What use is it?</p>

  <p><strong>Johnny:</strong> the code not compiling is the feedback that you needed to proceed. While previously you did not know where to start, now you have a clear goal - make this code compile. Firstly, where do you get the displayed value from?</p>

  <p><strong>Benjamin:</strong> From the calculator display, of course!</p>

  <p><strong>Johnny:</strong> Then write it down how you get the value form the display.</p>

  <p><strong>Benjamin:</strong> like how?</p>

  <p><strong>Johnny:</strong> like this:</p>
  <pre>public class CalculatorSpecification
{

[Fact] public void
ShouldDisplay0WhenCreated()
{
 var displayedResult = calculator.Display();

 Assert.Equal("0", displayedResult);
}

}
</pre>

  <p><strong>Benjamin:</strong> I see. Now the calculator is not created anywhere. I need to create it somewhere now or it will not compile and this is my next step. Is this how it works?</p>

  <p><strong>Johnny:</strong> Yes, you are catching on quickly.</p>

  <p><strong>Benjamin:</strong> Ok then, here goes:</p>
  <pre>public class CalculatorSpecification
{

[Fact] public void
ShouldDisplay0WhenCreated()
{
 var calculator = new Calculator();

 var displayedResult = calculator.Display();

 Assert.Equal("0", displayedResult);
}

}
</pre>

  <p><strong>Johnny:</strong> Bravo!</p>

  <p><strong>Benjamin:</strong> Now the code still does not compile, because I do not have the <code>Calculator</code> class at all…</p>

  <p><strong>Johnny:</strong> sounds like a good reason to create it.</p>

  <p><strong>Benjamin:</strong> OK.</p>
  <pre>public class Calculator
{
}
</pre>

  <p><strong>Benjamin:</strong> Looks like the <code>Display()</code> method is missing too. I will add it.</p>
  <pre>public class Calculator
{
  public string Display()
  {
    return "0";
  } 
}
</pre>

  <p><strong>Johnny:</strong> Hey hey, not so fast!</p>

  <p><strong>Benjamin:</strong> What?</p>

  <p><strong>Johnny:</strong> You already provided an implementation that will make our current Statement true. Remember its name? <code>ShouldDisplay0WhenCreated</code> - and that is exactly what the code you wrote does. Before we arrive at this point, let us make sure this Statement can ever be evaluates as false. So for now, let us change it to this:</p>
  <pre>public class Calculator
{
  public string Display()
  {
    return "Once upon a time in Africa…";
  } 
}
</pre>

  <p><strong>Johnny:</strong> Look, now we can run the Specification and watch that Statement evaluate to false, because it expects “0”, but gets “Once upon a time in Africa…”.</p>

  <p><strong>Benjamin:</strong> Running… Ok, it is false. By the way, do you always use such silly values to make Statements false?</p>

  <p><strong>Johnny:</strong> Hahaha, no, I just did it to emphasize the point. Normally, I would write <code>return "";</code> or something similarly simple. Now we can evaluate the Statement and see it evaluate to false. Now we are sure that we have not yet implemented what is required for the Statement to be true.</p>

  <p><strong>Benjamin:</strong> I think I get it. For now, the Statement shows that we do not have something we need and gives us a reason to add this “thing”. When we do so, this Statement will show that we do have what we need. So what do we do now?</p>

  <p><strong>Johnny:</strong> Write the simplest thing that makes this Statement true.</p>

  <p><strong>Benjamin:</strong> like this?</p>
  <pre>public class Calculator
{
  public string Display()
  {
    return "0";
  } 
}
</pre>

  <p><strong>Johnny:</strong> Yes.</p>

  <p><strong>Benjamin:</strong> But that is not a real implementation. What is the value behind putting in a hardcoded string? The final implementation is not going to be like this for sure!</p>

  <p><strong>Johnny:</strong> You’re right. The final implementation is most probably going to be different. What we did, however, is still valuable because:</p>

  <ol>
    <li>You’re one step closer to implementing the final solution</li>

    <li>This feeling that this is not the final implementation points you towards writing more Statements. When there is enough Statements to make your implementation complete, it usually means that you have a complete Specification of class behaviors as well.</li>

    <li>If you treat making every Statement true as an achievement, this practice allows you to evolve your code without losing what you already achieved. If by accident you break any of the behaviors you’ve already implemented, the Specification is going to tell you because one of the existing Statements that were previously true will then evaluate to false. You can then either fix it or undo your changes using version control and start over from the point where all existing Statements were true.</li>
  </ol>

  <p><strong>Benjamin:</strong> looks like quite a few benefits. Still, I will have to get used to this kind of working.</p>

  <p><strong>Johnny:</strong> do not worry, it is central to TDD, so you will grasp it in no time. Now, before we proceed to the next Statement, let us look at what we already achieved. First, we wrote a Statement that turned out false. Then, we wrote just enough code to make the Statement true. Time for a step called Refactoring. In this step, we will take a look at the Statement and the code and remove duplication. Can you see what is duplicated between the Statement and the code?</p>

  <p><strong>Benjamin:</strong> both of them contain the literal “0”. The Statement has it here:</p>
  <pre>Assert.Equal("0", displayedResult);</pre>

  <p>and the implementation here:</p>
  <pre>return "0";</pre>

  <p><strong>Johnny:</strong> Good, let us eliminate this duplication by introducing a constant called <code>InitialValue</code>. The Statement will now look like this:</p>
  <pre>[Fact] public void
ShouldDisplayInitialValueWhenCreated()
{
 var calculator = new Calculator();

 var displayedResult = calculator.Display();

 Assert.Equal(Calculator.InitialValue, displayedResult);
}
</pre>

  <p>and the implementation:</p>
  <pre>public class Calculator
{
  public const string InitialValue = "0";
  public string Display()
  {
    return InitialValue;
  } 
}
</pre>

  <p><strong>Benjamin:</strong> The code looks better and having the constant in one place will make it more maintainable, but I think the Statement in its current form is weaker than before. We could change the <code>InitialValue</code> to anything and the Statement would still be true, since it does not force this constant to be “0”.</p>

  <p>That is right. We need to add it to our TODO list to handle this case. Can you write it down?</p>

  <p><strong>Benjamin:</strong> Sure. I will write it as “TODO: 0 should be used as an initial value.”</p>

  <p><strong>Johnny:</strong> Ok. We should handle it now, especially that it is part of the story we are currently implementing, but I will leave it for later just to show you the power of TODO list in TDD - whatever is on the list, we can forget and get back to when we have nothing better to do. Our next item from the list is this:</p>

  <h3 class="sigil_not_in_toc" id="u3f564a21-4fcf-42c1-8b74-b0f57676aff0">Statement 2: Calculator should display entered digits</h3>

  <table>
    <tr>
      <th>key sequence</th>

      <th>Displayed output</th>

      <th>Notes</th>
    </tr>

    <tr>
      <td>1,2,3</td>

      <td>123</td>

      <td>Entered digits are displayed</td>
    </tr>
  </table>

  <p><strong>Johnny:</strong> Benjamin, can you come up with a Statement for this behavior?</p>

  <p><strong>Benjamin:</strong> I will try. Here goes:</p>
  <pre>public void [Fact]
ShouldDisplayEnteredDigits()
{
  var calculator = new Calculator();
  
  calculator.Enter(1);
  calculator.Enter(2);
  calculator.Enter(3);
  var displayedValue = calculator.Display();

  Assert.Equal("123", displayedValue);
}
</pre>

  <p><strong>Johnny:</strong> I am glad that you got the part about naming and writing a Statement. One thing we will have to work on here though.</p>

  <p><strong>Benjamin:</strong> what is it?</p>

  <p><strong>Johnny:</strong> When we talked to Jane, we used examples with real values. These real values were extremely helpful in pinning down the corner cases and uncovering missing scenarios. They were easier to imagine as well, so they were a perfect suit for conversation. If we were automating these examples on acceptance level, we would use those real values as well. When we write unit-level Statements, however, we use a different technique to get this kind of specification more abstract. First of all, let me enumerate the weaknesses of the approach you just used:</p>

  <ol>
    <li>Making a method <code>Enter()</code> accept an integer value suggests that one can enter more than one digit at once, e.g. <code>calculator.Enter(123)</code>, which is not what we want. We could detect such cases and throw exceptions if the value is outside the 0-9 range, but there are better ways when we know we will only be supporting ten digits (0,1,2,3,4,5,6,7,8,9).</li>

    <li>The Statement does not clearly show the relationship between input and output. Of course, in this simple case it is pretty self-evident that the sum is a concatenation of entered digits, we do not want anyone who will be reading this Specification in the future to have to guess.</li>

    <li>The Statement suggests that what you wrote is sufficient for any value, which isn’t true, since the behavior for “0” is different (no matter how many times we enter “0”, the result is just “0”)</li>
  </ol>

  <p>Hence, I propose the following:</p>
  <pre>public void [Fact]
ShouldDisplayAllEnteredDigitsThatAreNotLeadingZeroes()
{
 //GIVEN
 var calculator = new Calculator();
 var nonZeroDigit = Any.Besides(DigitKeys.Zero);
 var anyDigit1 = Any.Of&lt;DigitKeys&gt;();
 var anyDigit2 = Any.Of&lt;DigitKeys&gt;();
          
 //WHEN
 calculator.Enter(nonZeroDigit);
 calculator.Enter(anyDigit1);
 calculator.Enter(anyDigit2);
          
 //THEN
 Assert.Equal(
  string.Format("{0}{1}{2}", 
   (int)nonZeroDigit, 
   (int)anyDigit1, 
   (int)anyDigit2
  ),
  calculator.Display()
 );
}
</pre>

  <p><strong>Benjamin:</strong> Johnny, I am lost! Can you explain what is going on here?</p>

  <p><strong>Johnny:</strong> Sure, what do you want to know?</p>

  <p><strong>Benjamin:</strong> For instance, what is this <code>DigitKeys</code> type doing here?</p>

  <p><strong>Johnny:</strong> It is supposed to be an enumeration (note that it does not exist yet, we just assume that we have it) to hold all the possible digits user can enter, which are 0-9. This is to ensure that user will not write <code>calculator.Enter(123)</code>. Instead of allowing to enter any number and then detecting errors, we are giving our users a choice from among only the valid values.</p>

  <p><strong>Benjamin:</strong> Now I get it. So how about the <code>Any.Besides()</code> and <code>Any.Of()</code>? What do they do?</p>

  <p><strong>Johnny:</strong> They are methods from a small utility library I am using when writing unit-level Specifications. <code>Any.Besides()</code> returns any value from enumeration besides the one supplied as an argument. Hence, the call <code>Any.Besides(DigitKeys.Zero)</code> means “any of the values contained in DigitKeys enumeration, but not DigitKeys.Zero”.</p>

  <p>The <code>Any.Of()</code> is simpler - it just returns any value in an enumeration. Note that when I create the values this way, I state explicitly that this behavior occurs when first digit is non-zero. This technique of using generated values instead of literals has its own principles, but let us leave it for later. I promise to give you a detailed lecture on it. Agree?</p>

  <p><strong>Benjamin:</strong> You better do, because for now, I feel a bit uneasy with generating the values - it seems like the Statement we are writing is getting less deterministic this way. The last question - what about those weird comments you put in the code? Given? When? Then?</p>

  <p><strong>Johnny:</strong> Yes, this is a convention that I use, not only in writing, but in thinking as well. I like to think about every behavior in terms of three elements: assumptions (given), trigger (when) and expected result (then). Using the words, we can summarize the Statement we are writing in the following way: “<strong>Given</strong> a calculator, <strong>when</strong> I enter some digits first one being other than zero, <strong>then</strong> they should all be displayed in order they were entered”. This is also something that I will tell you more about later.</p>

  <p><strong>Benjamin:</strong> Sure, for now I need just enough detail to understand what is going on - we can talk about the principles, pros and cons later. By the way, the following sequence of casts looks a little bit ugly:</p>
  <pre>  string.Format("{0}{1}{2}", 
   (int)nonZeroDigit, 
   (int)anyDigit1, 
   (int)anyDigit2
  )
</pre>

  <p><strong>Johnny:</strong> We will get back to it and make it more “smarter” in a second after we make this statement true. For now, we need something obvious. Something we know works. Let us evaluate this Statement. What is the result?</p>

  <p><strong>Benjamin:</strong> Failed, expected “331”, but was “0”.</p>

  <p><strong>Johnny:</strong> Good, now let us write some code to make this Statement true. First, let us introduce an enumeration of digits:</p>
  <pre>public enum DigitKeys
{
 Zero = 0,
 TODO1, //TODO
 TODO2, //TODO
 TODO3, //TODO
 TODO4, //TODO
}</pre>

  <p><strong>Benjamin:</strong> What is with all those bogus values? Should we not just enter all the digits we support?</p>

  <p><strong>Johnny:</strong> Nope, not yet. We still do not have a Statement which would say what digits are supported and thus make us add them, right?.</p>

  <p><strong>Benjamin:</strong> You say you need a Statement for an element to be in an enum??</p>

  <p><strong>Johnny:</strong> This is a specification we are writing, remember? It should say somewhere which digits we support, should it not?</p>

  <p><strong>Benjamin:</strong> It is difficult to agree with, especially that I am used to write unit tests, not Statements and in unit tests, I wanted to verify what I was unsure of.</p>

  <p><strong>Johnny:</strong> I will try to give you more arguments later. For now, just bear with me and note that adding such Statement will be almost effortless.</p>

  <p><strong>Benjamin:</strong> OK.</p>

  <p><strong>Johnny:</strong> Now for the implementation. Just to remind you - up to now, it looked like this:</p>
  <pre>public class Calculator
{
  public const string InitialValue = "0";
  public string Display()
  {
    return InitialValue;
  } 
}
</pre>

  <p>This is not enough to support displaying multiple digits (as we saw, because the Statement saying they should be supported was evaluated to false). So let us evolve the code to handle this case:</p>
  <pre>public class Calculator
{
 private int _result = 0;
      
 public void Enter(DigitKeys digit)
 {
  _result *= 10;
  _result += (int)digit; 
 }

 public string Display()
 {
  return _result.ToString();
 }
}
</pre>

  <p><strong>Johnny:</strong> Now the Statement is true so we can go back to it and make it a little bit prettier. Let us take a second look at it:</p>
  <pre>public void [Fact]
ShouldDisplayAllEnteredDigitsThatAreNotLeadingZeroes()
{
 //GIVEN
 var calculator = new Calculator();
 var nonZeroDigit = Any.Besides(DigitKeys.Zero);
 var anyDigit1 = Any.Of&lt;DigitKeys&gt;();
 var anyDigit2 = Any.Of&lt;DigitKeys&gt;();
          
 //WHEN
 calculator.Enter(nonZeroDigit);
 calculator.Enter(anyDigit1);
 calculator.Enter(anyDigit2);
          
 //THEN
 Assert.Equal(
  string.Format("{0}{1}{2}", 
   (int)nonZeroDigit, 
   (int)anyDigit1, 
   (int)anyDigit2
  ),
  calculator.Display()
 );
}
</pre>

  <p><strong>Johnny:</strong> Remember you said that you do not like the part where <code>string.Format()</code> is used?</p>

  <p><strong>Benjamin:</strong> Yeah, it seems a bit unreadable.</p>

  <p><strong>Johnny:</strong> Let us extract this part into a utility method and make it more general - we will need a way of constructing expected displayed output in many of our future Statements. Here is my go at this helper method:</p>
  <pre>string StringConsistingOf(params DigitKeys[] digits)
{
 var result = string.Empty;
      
 foreach(var digit in digits) 
 {
  result += (int)digit;
 }
 return result;
}</pre>

  <p>Note that this is more general as it supports any number of parameters. And the Statement after this extraction looks like this:</p>
  <pre>public void [Fact]
ShouldDisplayAllEnteredDigitsThatAreNotLeadingZeroes()
{
 //GIVEN
 var calculator = new Calculator();
 var nonZeroDigit = Any.Besides(DigitKeys.Zero);
 var anyDigit1 = Any.Of&lt;DigitKeys&gt;();
 var anyDigit2 = Any.Of&lt;DigitKeys&gt;();
          
 //WHEN
 calculator.Enter(nonZeroDigit);
 calculator.Enter(anyDigit1);
 calculator.Enter(anyDigit2);
          
 //THEN
 Assert.AreEqual(
  StringConsistingOf(nonZeroDigit, anyDigit1, anyDigit2),
  calculator.Display()
 );
}
</pre>

  <p><strong>Benjamin:</strong> Looks better to me. The Statement is still evaluated as true, which means we got it right, did we not?</p>

  <p><strong>Johnny:</strong> Not exactly. With such moves such as this one, I like to be extra careful. Let us comment out the body of the <code>Enter()</code> method and see if this Statement can still be made false by the implementation:</p>
  <pre>public void Enter(DigitKeys digit)
 {
  //_result *= 10;
  //_result += (int)digit; 
 }
</pre>

  <p><strong>Benjamin:</strong> Running… Ok, it is false now. Expected “243”, got “0”.</p>

  <p><strong>Johnny:</strong> good, now we are pretty sure that it works OK. Let us uncomment the lines we just commented out and move forward.</p>

  <h3 class="sigil_not_in_toc" id="ub7968b9c-798d-41a2-94ef-86e57921a82b">Statement 3: Calculator should display only one zero digit if it is the only entered digit even if it is entered multiple times</h3>

  <p><strong>Johnny:</strong> Benjamin, this should be easy for you, so go ahead and try it. It is really a variation of previous Statement.</p>

  <p><strong>Benjamin:</strong> Let me try… ok, here it is:</p>
  <pre>[Fact] public void 
ShouldDisplayOnlyOneZeroDigitWhenItIsTheOnlyEnteredDigitEvenIfItIsEnteredMultipleTimes()
{
 var zero = DigitKeys.Zero;
 var calculator = new Calculator();
      
 calculator.Enter(zero);
 calculator.Enter(zero);      
 calculator.Enter(zero);
      
 Assert.Equal(
  StringConsistingOf(DigitKeys.Zero), 
  calculator.Display()
 );
}</pre>

  <p><strong>Johnny:</strong> Good, you are learning fast! Let us evaluate this Statement.</p>

  <p><strong>Benjamin:</strong> It seems that our current code already fulfills the Statement. Should I try to comment some code to make sure this Statement can fail just like you did in the previous Statement?</p>

  <p><strong>Johnny:</strong> That would be wise thing to do. When a Statement is true without requiring you to change any production code, it is always suspicious. Just like you said, we have to modify production code for a second to force this Statement to be false, then undo this modification to make it true again. This isn’t as obvious as previously, so let me do it. I will mark all the added lines with <code>//+</code> comment so that you can see them easily:</p>
  <pre>public class Calculator
{
 int _result = 0;
 string fakeResult = "0"; //+
      
 public void Enter(DigitKeys digit)
 {
  _result *= 10;
  _result += (int)digit; 
  if(digit == DigitKeys.Zero) //+
  {  //+
    fakeResult += "0";  //+
  } //+
 }

 public string Display()
 {
  if(_result == 0)  //+
  {  //+
   return fakeResult;  //+
  }  //+
  return _result.ToString();
 }
}</pre>

  <p><strong>Benjamin:</strong> Wow, looks like a lot of code just to make the Statement false! Is it worth the hassle? We will undo this whole modification in a second anyway</p>

  <p><strong>Johnny:</strong> Depends on how confident you want to feel. I would say that it is usually worth it - at least you know that you got everything right. It might seem like a lot of work, but it actually took me about a minute to add this code and imagine you got it wrong and had to debug it on a production environment. _That_ would be a waste of time.</p>

  <p><strong>Benjamin:</strong> Ok, I think I get it. Since we saw this Statement turn false, I will undo this modification to make it true again.</p>

  <p><strong>Johnny:</strong> Sure.</p>

  <h2 id="sigil_toc_id_12">Epilogue</h2>

  <p>Time to leave Johnny and Benjamin, at least for now. I actually planned to make this chapter longer, and cover all the other operations, but I fear I would make this too long and get you bored. You should have a feel of how the TDD cycle looks like, especially that Johnny and Benjamin had a lot of conversations on many other topics in the meantime. I will be revisiting these topics later in the book. For now, so if you felt lost or unconvinced on any of the topics mentioned by Johnny, do not worry - I do not expect you to be proficient with any of the techniques shown in this chapter just yet. Time will come for that.</p>
</body>
</html>